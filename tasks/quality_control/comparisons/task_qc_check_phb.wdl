version 1.0

task qc_check_phb {
  input {
    # core inputs
    File? qc_check_table
    # {qc_metric: [value, type, operator, use_exception]}
    Map[String, Array[String?]+] qc_check_criteria
    File? irma_qc_table

    String? expected_taxon
    String? gambit_predicted_taxon

    Int disk_size = 100
    Int memory = 8
    Int cpu = 4
    String docker = "us-docker.pkg.dev/general-theiagen/theiagen/terra-tools:2024-08-27"
  }
  File qc_check_criteria_json = write_json(qc_check_criteria)
  command <<<
    python3 <<CODE
    import csv
    import json
    import pandas as pd
    import numpy as np

    # set a function to compare the input to a standard value
    # qc_note: the notes regarding the qc_check to be appended to
    # input: input value to examine (already cast to intended type)
    # expectation: should this input be >, >=, =, <, <= to the standard
    # standard: the value to compare the input to
    def compare(qc_note, variable_name, input_value, expectation, standard):
      # create empty variable to return
      qc_status = ""

      # check if input value exists
      if input_value is not None and not pd.isnull(input_value): 
        # perform check on every possible operator
        if expectation == ">":
          if (input_value > standard):
            print("DEBUG: " + variable_name + " (" + str(input_value) + ") was greater than the threshold of " + str(standard))
          else:
            print("DEBUG: " + variable_name + " (" + str(input_value) + ") was not greater than the threshold of " + str(standard))
            qc_note += variable_name + " (" + str(input_value) + ") was less than or equal to the minimum threshold of " + str(standard) + "; "

        elif expectation == ">=":
          if (input_value >= standard):
            print("DEBUG: " + variable_name + " (" + str(input_value) + ") was greater than or equal to the threshold of " + str(standard))
          else:
            print("DEBUG: " + variable_name + " (" + str(input_value) + ") was not greater than or equal to the threshold of " + str(standard))
            qc_note += variable_name + " (" + str(input_value) + ") was less than the minimum threshold of " + str(standard) + "; "

        elif expectation == "=":
          if (input_value == standard):
            print("DEBUG: " + variable_name + " (" + str(input_value) + ") was equal to the threshold of " + str(standard))
          else:
            print("DEBUG: " + variable_name + " (" + str(input_value) + ") was not equal to the threshold of " + str(standard))
            qc_note += variable_name + " (" + str(input_value) + ") was not equal to the threshold of " + str(standard) + "; "
            
        elif expectation == "<":
          if (input_value < standard):
            print("DEBUG: " + variable_name + " (" + str(input_value) + ") was less than the threshold of " + str(standard))
          else:
            print("DEBUG: " + variable_name + " (" + str(input_value) + ") was not less than the threshold of " + str(standard))
            qc_note += variable_name + " (" + str(input_value) + ") was greater than or equal to the maximum threshold of " + str(standard) + "; "
            
        elif expectation == "<=":
          if (input_value <= standard):
            print("DEBUG: " + variable_name + " (" + str(input_value) + ") was less than or equal to the threshold of " + str(standard))
          else:
            print("DEBUG: " + variable_name + " (" + str(input_value) + ") was not less or equal to the threshold of " + str(standard))
            qc_note += variable_name + " (" + str(input_value) + ") was greater than the maximum threshold of " + str(standard) + "; "

      # if the qc_note has a value, then it has failed a check
      if (len(qc_note) > 0):
        qc_status = "QC_ALERT"

      return qc_note, qc_status

    # create two empty variables for results to be added to
    qc_status = ""
    qc_note = ""
    
    # import the qc_check_table into a pandas data frame
    qc_check_df = pd.read_csv("~{qc_check_table}", sep = '\t', index_col = "taxon")

    # lower-case for case-insensitive parsing
    qc_check_df.columns = map(str.lower, qc_check_df.columns)
    
    # import and clean the qc_check_criteria json generated by WDL
    with open("~{qc_check_criteria_json}", "r") as f:
      qc_check_criteria_dirty = json.load(f)
    qc_check_criteria = {}
    for wdl_dict in qc_check_criteria_dirty:
      key = wdl_dict["left"]
      value_list = wdl_dict["right"]
      # skip NoneType (WDL null) values
      if value_list[0] is not None:
        qc_check_criteria[key.lower()] = value_list

    # extract the list of taxon to examine
    qc_check_taxa = qc_check_df.index.values.tolist()

    # preferentially use a user-provided expected taxon; otherwise, use the gambit predicted taxon
    expected_taxon = "~{expected_taxon}"
    gambit_predicted_taxon = "~{gambit_predicted_taxon}"

    # check if an expected_taxon or gambit_predicted taxon was detected
    if (expected_taxon):
      qc_taxon = expected_taxon.replace(" ", "_")
      print("DEBUG: User-provided expected_taxon was found and will be used for QC check")
    elif (gambit_predicted_taxon):
      qc_taxon = gambit_predicted_taxon.replace(" ", "_")
      print("DEBUG: No user-provided expected_taxon found; will be using gambit_predicted_taxon for QC check")
    else:
      qc_status = "QC_NA"
      qc_note = "No expected_taxon or gambit_predicted_taxon was found; qc_check could not proceed"
    
    # if a qc_taxon was generated, check to see if that taxon is in the qc_check_table
    if (qc_status != "QC_NA"):
      matching_taxon = []
      for taxa in qc_check_taxa:
        if taxa in qc_taxon:
          matching_taxon.append(taxa)
          print("DEBUG: the qc_taxon was found, adding to matching_taxon list")
      if len(matching_taxon) < 1: # if no taxon were found
        qc_status = "QC_NA"
        qc_note = "No matching taxon were found in the qc_check table; qc_check could not proceed"
      elif len(matching_taxon) > 1: # if more than one taxon were found
        qc_status = "QC_NA"
        qc_note = "Multiple matching taxa were detected in the qc_check_table; qc_check could not proceed"
      else: # only one taxon was found
        taxon_df = qc_check_df.loc[[matching_taxon[0]]] # extract only the values for that taxa
        print(f"DEBUG: exactly one matching taxon was found: {matching_taxon}, proceeding with qc_check")

        # remove columns where all values are null
        taxon_df = taxon_df.replace(r'^\s*$', np.nan, regex=True)
        taxon_df = taxon_df.dropna(how='all', axis=1)
        
      # perform qc_check on any metrics in the qc_check_table
      if (qc_status != "QC_NA"):
        qc_check_metrics = taxon_df.columns.values.tolist()
        print(f"DEBUG: Found qc_check_metrics: {qc_check_metrics}")

        # iterate through standard checks first
        for metric in sorted(qc_check_metrics):
          # allow "min" and "max" suffixes to be used in qc_check_criteria
          if metric.endswith("_min"):
            operator = ">="
            base_metric = metric[:-4]
          elif metric.endswith("_max"):
            operator = "<="
            base_metric = metric[:-4]
          else:
            operator = None
            base_metric = metric
          if base_metric in qc_check_criteria:
            obs_val = qc_check_criteria[base_metric][0]
            val_type_str = qc_check_criteria[base_metric][1]
            # yield to the operator from "min" / "max" suffixes if present
            if not operator:
              operator = qc_check_criteria[base_metric][2]
            exception_flag = qc_check_criteria[base_metric][3]
            if val_type_str == "int":
              val_type = int
            elif val_type_str == "float":
              val_type = float
            else:
              raise ValueError(f"qc_check_criteria value type {val_type_str} not recognized; must be 'int' or 'float'")
            # we only process metrics without exception_flag set to true here (assume others are not exceptions)
            if exception_flag != "true":
              qc_note, qc_status = compare(qc_note, metric, val_type(obs_val), operator, val_type(taxon_df[metric][0]))
              qc_check_metrics.remove(metric)

        # iterate through special exceptions
        for metric in sorted(qc_check_metrics):
          # allow "min" and "max" suffixes to be used in qc_check_criteria
          if metric.endswith("_min"):
            operator = ">="
            base_metric = metric[:-4]
          elif metric.endswith("_max"):
            operator = "<="
            base_metric = metric[:-4]
          else:
            operator = None
            base_metric = metric
          if base_metric in qc_check_criteria:
            obs_val = qc_check_criteria[base_metric][0]
            val_type_str = qc_check_criteria[base_metric][1]
            # yield to the operator from "min" / "max" suffixes if present
            if not operator:
              operator = qc_check_criteria[base_metric][2]
            exception_flag = qc_check_criteria[base_metric][3]
            # we only process metrics with exception_flag set to true here
            if exception_flag == "true":
              if val_type_str == "int":
                val_type = int
              elif val_type_str == "float":
                val_type = float
              else:
                raise ValueError(f"qc_check_criteria value type {val_type_str} not recognized; must be 'int' or 'float'")
              if base_metric == "busco_completeness":
                  busco_completeness = qc_check_criteria[base_metric][0].split("C:")[1].split("%")[0]
                  qc_note, qc_status = compare(qc_note, metric, float(busco_completeness), ">=", float(taxon_df[metric][0]))
                  qc_check_metrics.remove(metric)
              else:
                try:
                  qc_note, qc_status = compare(qc_note, metric, val_type(obs_val), operator, val_type(taxon_df[metric][0]))
                except:
                  qc_note += f"{base_metric} ({obs_val}) could not be cast to {val_type_str}; "
                  qc_status = "QC_ALERT"
                qc_check_metrics.remove(metric)
  
        # check segment-level qc metrics via the irma_qc_table if it exists
        if "~{irma_qc_table}":
          irma_qc_table = pd.read_csv("~{irma_qc_table}", sep = '\t', index_col = "Sample")
          to_rm = set()
          # iterate through segments
          for index, row in irma_qc_table.iterrows():
            if '_' in row['Reference']:
              segment_name = row['Reference'].lower()[:row['Reference'].rfind('_')]
            else:
              segment_name = row['Reference'].lower()
            ref_var = segment_name + "_percent_reference_coverage"
            med_var = segment_name + "_median_coverage"
            snv_var = segment_name + "_snv_max"
            print("DEBUG: Checking QC metrics for segment: " + segment_name)
            ref_val = row['% Reference Covered']
            med_val = row['Median Coverage']
            snv_val = row['Count of Minor SNVs (AF >= 0.05)']
            # prioritize segment-specific thresholds if they exist
            if ref_var in qc_check_metrics:
              qc_note, qc_status = compare(qc_note, ref_var, float(ref_val), ">=", float(taxon_df[ref_var][0]))
              to_rm.add(ref_var)
            elif "segment_percent_reference_coverage" in qc_check_metrics:
              qc_note, qc_status = compare(qc_note, ref_var, float(ref_val), ">=", float(taxon_df["segment_percent_reference_coverage"][0]))
              to_rm.add("segment_percent_reference_coverage")
            if med_var in qc_check_metrics:
              qc_note, qc_status = compare(qc_note, med_var, float(med_val), ">=", float(taxon_df[med_var][0]))
              to_rm.add(med_var)
            elif "segment_median_coverage" in qc_check_metrics:
              qc_note, qc_status = compare(qc_note, med_var, float(med_val), ">=", float(taxon_df["segment_median_coverage"][0]))
              to_rm.add("segment_median_coverage")
            if snv_var in qc_check_metrics:
              try:
                qc_note, qc_status = compare(qc_note, snv_var, int(snv_val), "<=", int(taxon_df[snv_var][0]))
              # Catch NaNs: we don't cast to int initially because float casting could cause equalities to fail
              except ValueError:
                qc_note, qc_status = compare(qc_note, snv_var, float(snv_val), "<=", int(taxon_df[snv_var][0]))
              to_rm.add(snv_var)
            elif "segment_snv_max" in qc_check_metrics:
              try:
                qc_note, qc_status = compare(qc_note, snv_var, int(snv_val), "<=", int(taxon_df["segment_snv_max"][0]))
              # Catch NaNs: we don't cast to int initially because float casting could cause equalities to fail
              except ValueError:
                qc_note, qc_status = compare(qc_note, snv_var, float(snv_val), "<=", int(taxon_df["segment_snv_max"][0]))
              to_rm.add("segment_snv_max")
          qc_check_metrics = [m for m in qc_check_metrics if m not in to_rm]

        if (len(qc_check_metrics) > 0):
          qc_status = "QC_ALERT"
          qc_note += f"one or more columns in qc_check_metrics was missing a required input: {qc_check_metrics}"

      if (qc_status != "QC_NA") and (qc_status != "QC_ALERT"):
        qc_check = "QC_PASS"
      else:
        qc_check = qc_status + ": " + qc_note
        qc_check = qc_check.rstrip('; ')

      with open("QC_CHECK", 'wt') as out:
        out.write(qc_check)
      
    CODE

  >>>
  output {
    String qc_check = read_string("QC_CHECK")
    File? qc_standard = qc_check_table
  }
  runtime {
    docker: docker
    memory: memory + " GB"
    cpu: cpu
    disks: "local-disk " + disk_size + " SSD"
    disk: disk_size + " GB"
    maxRetries: 3
    preemptible: 0
  }
}